# Android

- [Android 05: 2025-08-15](#android-05-2025-08-15)
  - [Toast / Всплывающие сообщения](#toast--всплывающие-сообщения)
  - [Рекомендации по хранению шрифтов](#рекомендации-по-хранению-шрифтов)
  - [ConstraintLayout](#constraintlayout)
    - [Основные понятия](#основные-понятия)
  - [Добавление активности](#добавление-активности)
      - [Exploring a project / Изучение проекта](#exploring-a-project--изучение-проекта)
        - [Using the Project pane / Панель проекта, файловая структура Android Studio](#using-the-project-pane--панель-проекта-файловая-структура-android-studio)
        - [Using the editor pane / Панель редактора](#using-the-editor-pane--панель-редактора)
      - [Understanding the Android manifest / Манифест приложения Android](#understanding-the-android-manifest--манифест-приложения-android)
        - [Android namespace and application tag / Теги `namespace` и `application`](#android-namespace-and-application-tag--теги-namespace-и-application)
        - [Automatic backup / Автоматическое резервное копирование](#automatic-backup--автоматическое-резервное-копирование)
  - [Добавление перехода на другой экран](#добавление-перехода-на-другой-экран)
  - [Добавление экрана проектов](#добавление-экрана-проектов)
    - [RelativeLayout](#relativelayout)
    - [Сравнение RelativeLayout и ConstraintLayout](#сравнение-relativelayout-и-constraintlayout)
  - [Добавление блока идентификации пользователя с аватаркой](#добавление-блока-идентификации-пользователя-с-аватаркой)
    - [Работа с изображением](#работа-с-изображением)
    - [Добавление подчеркивания](#добавление-подчеркивания)
  - [Добавление рамки](#добавление-рамки)
    - [Рамка полей ввода](#рамка-полей-ввода)
  - [TableLayout / Добавление списков](#tablelayout--добавление-списков)
  - [Добавление прокрутки](#добавление-прокрутки)
- [Android 06: 2025-08-19](#android-06-2025-08-19)
  - [Добавление иконки быстрого запуска](#добавление-иконки-быстрого-запуска)
  - [Передача данных](#передача-данных)
  - [Добавление простейшей валидации](#добавление-простейшей-валидации)
      - [Проверка на пустоту](#проверка-на-пустоту)
  - [Создание вспомогательных виджетов для полей ввода](#создание-вспомогательных-виджетов-для-полей-ввода)
    - [Подключение виджета выбора дат](#подключение-виджета-выбора-дат)
      - [Форматирование строк](#форматирование-строк)
    - [Добавление виджета скрытия/показа пароля](#добавление-виджета-скрытияпоказа-пароля)
    - [Использование FrameLayout для создания наложений](#использование-framelayout-для-создания-наложений)
    - [Использование scope-функций для рефакторинга кода](#использование-scope-функций-для-рефакторинга-кода)

## Android 05: 2025-08-15

### Toast / Всплывающие сообщения
Пример добавления всплывающего сообщения:
```kotlin
Toast.makeText(this, "Email: $email\nPassword: $password", Toast.LENGTH_SHORT).show()
```

`Toast` — это класс в Android, который показывает небольшое временное всплывающее сообщение (попап) на экране. Его удобно использовать для кратких уведомлений пользователю.

`makeText(...)` — статический метод, который создаёт объект `Toast` с заданным текстом и длительностью показа.

Параметры метода `makeText`:

- `this` — контекст, в котором показывается `Toast` (обычно `Activity` или `Context`). Здесь `this` указывает на текущий объект `Activity`.

- `"Email: $email\nPassword: $password"` — строка, которая будет отображена. Это строка с интерполяцией Kotlin: переменные `email` и `password` подставляются в текст, `\n` — перенос строки.

- `Toast.LENGTH_SHORT` — длительность показа всплывающего сообщения (короткая по времени).

Далее `.show()` — метод, который показывает созданный Toast на экране.

**Итог**: при вызове этой строки в приложении пользователю на короткое время выводится небольшое уведомление с введённым Email и Паролем.

Это удобно для отладки или информирования пользователя о действиях.

`Toast.LENGTH_SHORT` — это встроенная константа в Android, которая определяет, что всплывающее сообщение (`Toast`) будет показываться на экране короткое время, примерно 2 секунды (2000 миллисекунд).

В Android есть две стандартные константы для длительности `Toast`:

| Константа          | Время отображения          |
| ------------------ | -------------------------- |
| `Toast.LENGTH_SHORT` | около 2 секунд (2000 мс)   |
| `Toast.LENGTH_LONG`  | около 3.5 секунд (3500 мс) |

Использование:
```kotlin
Toast.makeText(context, "Сообщение", Toast.LENGTH_SHORT).show()
```

Позволяет показать короткое уведомление, которое автоматически исчезнет примерно через 2 секунды без дополнительного взаимодействия пользователя.

Таким образом, `Toast.LENGTH_SHORT` задаёт именно время отображения `Toast` — короткое, по умолчанию удобное для большинства уведомлений.

### Рекомендации по хранению шрифтов
Шрифты, добавленные в папку *res/font* в Android-проекте, следует сохранять в системе контроля версий (например, git). Вот почему:

- Папка *res/font* — это часть исходных ресурсов проекта, аналогично папкам с *layout*, *drawable* и *values*.

- Все файлы шрифтов (.ttf, .otf), помещённые в *res/font*, являются неотъемлемой частью проекта и нужны для его сборки и корректной работы интерфейса.

- Если не сохранять шрифты в системе контроля версий, другие разработчики или CI/CD системы не смогут получить эти шрифты при клонировании репозитория, что приведёт к ошибкам компиляции или отсутствию кастомных шрифтов в приложении.

- Хотя возможен вариант использования "скачиваемых" шрифтов из поставщиков (downloadable fonts), при которых шрифты не включаются в APK напрямую, в большинстве случаев кастомные шрифты кладут именно в *res/font* и хранят их в репозитории.

- Увеличение размера репозитория из-за шрифтов обычно незначительно по сравнению с преимуществами удобства управления ресурсами проекта.

Таким образом, все файлы шрифтов, которые добавляются в *res/font*, должны быть версионированы так же, как и остальные ресурсы проекта.

### ConstraintLayout
На прошлом занятии мы познакомились с новым компоновщиком — `ConstraintLayout`. Как и все другие макеты, `ConstraintLayout` управляет позиционированием и размером содержащихся в нем визуальных компонентов (также называемых <dfn title="виджет">виджетами</dfn>). Это делается на основе ограничений соединений, установленных для каждого дочернего виджета.

**`ConstraintLayout`** представляет контейнер, который позволяет создавать гибкие и масштабируемые визуальные интерфейсы.

#### Основные понятия
Чтобы полностью понять и использовать `ConstraintLayout`, важно понять следующие ключевые понятия:
- **Ограничения** (constraints)

    Это связи между краями визуальных компонентов (виджетов) внутри `ConstraintLayout`. Например, левая сторона одного виджета может быть привязана к правой стороне другого, или верхняя к верхней стороне контейнера. Ограничения бывают горизонтальные и вертикальные. Они задают расположение и размеры элементов относительно друг друга и родительского контейнера.

- **Поля** (gaps/margins)

    Поля — это отступы между виджетами или между виджетами и краями `ConstraintLayout`. Они задаются параметрами `margin`, чтобы визуальные компоненты не прилипали плотно друг к другу, обеспечивая красивое расстояние и выравнивание.

- **Противоположные ограничения** (opposite constraints)

    Это ограничения, задающие связи противоположных сторон виджета, например, левая и правая стороны виджета привязаны к разным элементам. В результате размер виджета может автоматически подстраиваться под пространство между этими ограничениями.

- **Смещение ограничений** (bias)

    Смещение — это настройка, которая определяет, сколько пространство между двумя ограничениями занимает элемент ближе к одному из них. Например, горизонтальный `bias` устанавливает позицию виджета между левым и правым ограничениями, где 0 — ближе к левому, 1 — к правому, 0.5 — по центру.

- **Цепи** (chains)

    Цепь — это специальный тип связей между несколькими виджетами, когда они взаимосвязаны ограничениями так, что можно управлять их общим расположением и распределением пространства, например, равномерно или сближенно.

- **Стили цепочек** (chain styles)

    Есть три основных стиля цепочек:

    - Spread — равномерное распределение элементов по всей доступной ширине/высоте.

    - Spread_inside — элементы распределены, но первый и последний располагаются у краёв.

    - Packed — элементы сжаты вместе и расположены в одной части пространства с возможностью смещения (bias).

- **Группы** (groups)

    Группа — это объект в `ConstraintLayout`, который позволяет управлять несколькими виджетами как одним целым, например, установить их видимость одновременно.

- **Барьеры** (barriers)

    Барьер — это виртуальная граница, которая может динамически изменять свое положение в зависимости от размеров виджетов. Используется для выравнивания и ограничения элементов по одной линии, даже если размеры элементов изменяются.

- **Поток** (flow)

    Flow — это расширение `ConstraintLayout`, аналогичное Flexbox или `LinearLayout` с переносом. Он автоматизирует расположение элементов в несколько строк или столбцов с управлением переносом и отступами.

### Добавление активности
Чтобы добавить переход на экран регистрации, необходимо добавить класс `Activity`. ПКМ > New > Activity > Empty Views Activity.

Задать имя активности в CamelCase и убрать галочку у Generate Layout Files, если уже имеется файл layout.

Связать файл `RegistrationActivity` с layout-файлом, указав имя макета в `setContentView()`:
```kotlin
package com.example.stitch_tracker

import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity

class RegistrationActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.registration_activity)

        val loginInput = findViewById<EditText>(R.id.etxtLog)
        val emailInput = findViewById<EditText>(R.id.etxtName)
        val passwordInput = findViewById<EditText>(R.id.etxtPassRep)
        val registerBtn = findViewById<Button>(R.id.submitBtn)

        registerBtn.setOnClickListener {
            val login = loginInput.text.toString()
            val email = emailInput.text.toString()
            val password = passwordInput.text.toString()

            if (login.isNotBlank() && password.isNotBlank()) {
                // Здесь можно добавить валидацию и логику регистрации
                Toast.makeText(this, "Регистрация успешно выполнена!\n$login", Toast.LENGTH_SHORT).show()
                finish() // Закрыть регистрацию и вернуться назад
            } else {
                Toast.makeText(this, "Пожалуйста, введите логин и пароль", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

Добавление активности через интерфейс Android Studio позволит автоматически добавить соответствующую запись в манифест приложения, чтобы система знала про неё. При этом в файл *AndroidManifest.xml* Android-проекта внутри элемента `<application>`, рядом с уже существующими `<activity>` элементами, добавляется следующая строка:
```xml
<activity android:name=".RegistrationActivity" />
```

Android Studio обычно хранит этот файл по пути *app/src/main/AndroidManifest.xml*.

Добавление активности в манифест обязательно для того, чтобы система могла её запускать при вызове из кода (через `Intent`).

Вот пример правильного размещения:
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.stitch_tracker">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Здесь добавляем вашу новую регистрацию активности -->
        <activity android:name=".RegistrationActivity" />

    </application>

</manifest>
```

После этого при вызове из кода
```kotlin
startActivity(Intent(this, RegistrationActivity::class.java))
```

будет запускаться новая активность.

##### Exploring a project / Изучение проекта
Проект в Android Studio содержит весь исходный код и все ресурсы приложения. Эти ресурсы включают макеты, строки, цвета, размеры и изображения. Главное окно Android Studio состоит из нескольких логических областей, или *панелей* (*panes*), как показано на рисунке ниже.

![App project panes](./img/as_gradle_in_project_pane_annot.png)

На рисунке выше обозначены:

1. **Панель инструментов** (**Toolbar**): предоставляет широкий набор действий, включая запуск приложения и инструментальных средств Android.
2. **Панель навигации** (**Navigation bar**): позволяет перемещаться по проекту и открывать файлы для редактирования.
3. **Панель проекта** (**Project pane**): отображает файлы проекта в одном из иерархических представлений. На рисунке выше выбран режим представления Android.
4. **Редактор** (**Editor**): содержимое выбранного файла проекта. Например, после выбора макета (как показано на рисунке выше) панель редактора отображает редактор макетов с инструментами для редактирования макета. После выбора файла с Java-кодом панель редактора показывает код Java с инструментами для редактирования этого кода.
5. **Вкладки** (**Tabs**) слева, справа и внизу окна: можно нажимать на вкладки, чтобы открыть другие панели, например, **Logcat** для отображения панели **Logcat** с сообщениями журнала отладки или **TODO**, чтобы управлять задачами.

Строка состояния внизу окна Android Studio отображает статус проекта и самой среды Android Studio, а также любые предупреждения или сообщения. В строке состояния можно отслеживать прогресс сборки.

**Совет**: чтобы увеличить доступное пространство экрана, можно реорганизовать главное окно, скрывая или перемещая панели. Также для доступа к большинству функций можно использовать клавиатурные сокращения. Полный список горячих клавиш можно найти в разделе [Клавиатурные сочетания](https://developer.android.com/studio/intro/keyboard-shortcuts.html).

###### Using the Project pane / Панель проекта, файловая структура Android Studio
[68831dd263e4ad8e0adf4176](https://e-learn.petrocollege.ru/mod/page/view.php?id=345163)

Панель проекта дает возможность просматривать различные варианты организации структуры проекта. Вызвать ее можно нажатием на значок вкладки **Проект** (**Project**) в виде папки, расположенный в вертикальной колонке, закрепленной слева в окне Android Studio.

В Android Studio существует два основных типа представления файловой структуры проекта. Один из них — **Android View** (*обобщенный*), другой — **Project View** (*подробный*). Большинство начинающих используют Android View (обобщенный), так как он тематически группирует ресурсы, абстрагируясь от реальной файловой структуры проекта, демонстрируемой подробным режимом отображения (Project View).

Для отображения проекта в стандартной иерархии **Android** (обобщенный тип представления) нужно выбрать пункт *Android* в меню с указывающей вниз стрелкой, расположенному слева в верхнем левом углу панели проекта.

![Android project menu](./img/as_project_android_menu.png)

> **Примечание**: далее по ходу текста панель проекта, установленная в режим отображения **Android**, обозначается как панель **Project** > **Android** (**Проект** > **Android**).

Стандартный проект Android содержит различные типы модулей приложений, файлы исходного кода и файлы ресурсов. Здесь локализована бизнес-логика основного приложения (Java / Kotlin), файлы для рисования (изображения, векторная графика), файлы макета пользовательского интерфейса приложения, *mipmap* (файлы значков приложения), цвета (фирменный цвет приложения), строки (все тексты, используемые для локализации приложения), стили (предопределенные или определяемые пользователем стили приложения), файл gradle на уровне приложения (управление зависимостями).

Структура приложения в обобщенном режиме схематически может быть представлена следующим образом:
```
.
├──📂 app                   # Файлы приложения
│   ├──📁 manifests         # Манифесты
│   ├──📁 kotlin+java       # Программный код (классы)
│   ├──📁 assets            # Активы (цифровые и произвольные объекты)
│   ├──📂 res               # Ресурсы
│   │   ├──📁 drawable      # Рисование (изображения)
│   │   ├──📁 font          # Шрифты
│   │   ├──📁 layout        # Разметка (макеты)
│   │   ├──📁 mipmap        # Иконки запуска (значки)
│   │   ├──📁 raw           # Необработанные данные (мультимедиа)
│   │   └──📁 values        # Значения ресурсов
│   └──📁 res (generated)   # Сгенерированные сборкой ресурсы
└──📁 Gradle Scripts        # Файлы системы сборки
```

- **Файлы Gradle**

  При первом создании проекта приложения панель **Project** > **Android** появляется вместе с раскрытой папкой *Gradle Scripts*, как показано на рисунке ниже. Скрывать и отображать содержимое этого каталога можно, нажимая на значок в виде треугольной стрелки. Папка *Gradle Scripts* содержит все файлы, используемые системой сборки.

  ![Android Gradle folder](./img/as_project_android_gradle_folder.png)

  Gradle — это автоматизированная система сборки (с открытым исходным кодом), которая используется для автоматизации сборки, тестирования, развертывания и т.д. Каждому проекту Android требуется Gradle для создания *apk* из файлов *.java* и *.xml* в проекте. Рассматриваемый ресурс расположен в корневом каталоге проекта, и его основная функция заключается в определении конфигураций сборки, которые будут применяться ко всем модулям в проекте.

  Здесь находится ряд файлов, которые используются для определения конфигурации сборки, которая может быть применена ко всем модулям приложения. В *build.gradle (Project)* содержатся сценарии сборки, а файл *build.gradle (Module:app)* задает дополнительные библиотеки и конфигурацию модуля сборки. Плагины и реализации, определенные здесь, используются для создания конфигураций, которые могут быть применены ко всем модулям приложения. Этот файл создаётся выбранным шаблоном `Activity`. Данный файл содержит атрибут `minSdkVersion`, объявляющий минимальную версию Android для приложения, а также атрибут `targetSdkVersion`, объявляющий максимальную (новейшую) версию, под которую оптимизировано приложение.

  Данный файл также включает в себя список <dfn title="зависимости">зависимостей</dfn>, представляющих собой библиотеки, необходимые для работы кода — например, библиотека `AppCompat`, обеспечивающая поддержку большого диапазона версий Android.

- **Манифесты**

    Папка манифестов включает файл манифеста *AndroidManifest.xml* для создания приложения под Android. Этот файл содержит такую информацию о приложении, как версия Android, метаданные, пакет состояний для файла Kotlin и другие компоненты приложения. Он выступает в качестве посредника между ОС Android и разрабатываемым приложением.

    Файл манифеста является важной частью приложения, поскольку он определяет структуру и метаданные приложения, его компоненты и требования. Этот файл содержит узлы для каждого из действий, служб, поставщиков контента и широковещательного приемника (broadcast receiver — приёмник широковещательных сообщений), которые создают приложение, и, используя фильтры намерений и разрешения, определяют, как они координируются друг с другом и другими приложениями.

- **Код приложения**

  Для просмотра и редактирования программного кода необходимо раскрыть папку *app*, развернуть каталог *java* и папку *com.example.android.helloworld*. Чтобы открыть файл исходного кода в редакторе, нужно два раза щелкнуть на файле под названием *MainActivity*.

  ![Android App folder](./img/as_project_android_app_folder.png)

  Папка *java*/*kotlin+java* содержит все файлы исходного кода (классы) Java (.java) и Kotlin (.kt), которые создаются во время разработки приложения, включая другие (тестовые) файлы. Каждый компонент ([`Activity`](https://developer.android.com/reference/android/app/Activity.html), [`Service`](https://developer.android.com/reference/android/app/Service.html) или любой другой, например, [`Fragment`](https://developer.android.com/reference/android/app/Fragment.html)) определяется как класс (Java или Kotlin), причем, как правило, каждый в своем файле. Тесты и другие классы Java также расположены здесь. Если создается какой-либо новый проект с использованием Kotlin, файл класса *MainActivity.kt* по умолчанию будет создан автоматически под именем пакета.

  Папка *java* содержит три подкаталога:

  - *com.example.hello.helloworld* (или указанное пользователем имя домена): все файлы для пакета находятся в папке с именем этого пакета. Для пробного приложения Hello World создается единственный пакет, содержащий только *MainActivity.java*. Первая активность (экран), которую видит пользователь и которая инициализирует ресурсы для всего приложения, по общепринятому соглашению имеет имя *MainActivity* (расширение файла в панели **Project** > **Android** опускается).

  - *com.example.hello.helloworld(androidTest)*: эта папка предназначена для хранения инструментальных тестов и содержит файл с шаблонной заготовкой для тестирования. <dfn title="инструментальные тесты">Инструментальные тесты</dfn> (Instrumentation Tests) выполняются на реальном устройстве или эмуляторе, имеют доступ к классам и методам Android и могут взаимодействовать с компонентами системы, такими как база данных, API, `SharedPreferences` и пользовательский интерфейс. Эти тесты покрывают интеграцию и взаимодействие компонентов приложения с системой и внешними сервисами. Инструментальные тесты могут включать подвиды, например UI-тесты, которые эмулируют взаимодействие пользователя с приложением. Как правило, инструментальные тесты медленнее модульных, но позволяют проверить поведение приложения в реальных условиях.

  - *com.example.hello.helloworld(test)*: данный каталог предназначен для модульных тестов и содержит автоматически созданный файл, являющийся шаблоном модульного тестирования. <dfn title="модульные тесты">Модульные тесты</dfn> (Unit Tests) проверяют отдельные модули или компоненты кода в изоляции, без зависимости от Android-фреймворка. Они выполняются локально на JVM (виртуальной машине Java) и предназначены для тестирования мелких блоков логики, например отдельных функций или методов. Для модульных тестов часто используется фреймворк JUnit. Модульные тесты — это тесты низкого уровня для проверки бизнес-логики и функций без зависимости от Android-среды. Эти тесты очень быстрые и помогают выявлять ошибки на раннем этапе разработки.

- **Файлы разметки**

  Как правило, отдельная активность ассоциирована с макетом представлений пользовательского интерфейса, определенного в файле XML. Этот XML-файл содержит разметку интерфейса и обычно называется так же, как соответствующий ему экземпляр `Activity`. Для просмотра и редактирования файла разметки необходимо раскрыть папку *res* и *layout*, находящуюся внутри нее. На рисунке, представленном ниже, файл макета (разметки) называется *activity_main.xml*.

  Открыть его в редакторе макетов можно двойным щелчком. Файлы разметки пишутся в формате XML.

  ![Android res folder](./img/as_project_android_res_folder.png)

- **Файлы ресурсов**

  Папка ресурсов (*res*) является важнейшей папкой, поскольку она содержит все некодовые источники, такие как XML-макеты, изображения и строки пользовательского интерфейса для приложения Android. Папка *res* включает следующие подкаталоги:

  - *drawable*: здесь хранятся все изображения приложения. Данный каталог содержит различные типы изображений, используемых для разработки приложения. Необходимо добавить все изображения в папку для рисования для разработки приложения.

  - *font*/*fonts*: создаётся внутри папки ресурсов *res* (то есть по пути *res/font*) и используется для хранения файлов шрифтов в формате .ttf или .otf. В эту папку помещают собственные (кастомные) шрифты, которые будут использоваться в приложении как ресурс. Android Studio автоматически создаёт соответствующие идентификаторы для шрифтов в классе `R`, чтобы к ним можно было обращаться программно через `R.font.<имя_шрифта>`. Папка *font* появилась в Android начиная с API 26 (Android 8.0) и облегчает работу с шрифтами в XML и коде. Вместо копирования файлов в папку *assets/fonts* (где шрифты требуют ручного подключения через `Typeface.createFromAsset()`), помещая шрифты в *res/font*, можно использовать теги `fontFamily` в XML-разметке для установки шрифтов. Таким образом, если нужно добавить кастомные шрифты в проект привычным способом с поддержкой современных возможностей Android, можно создать папку *font* внутри *res* (*app/src/main/res/font*) и положить туда файлы .ttf или .otf. Таким образом, папка *font* — это современный стандарт хранения и использования шрифтов в Android-проектах. Об особенностях использовании папки *assets* для тех же целей см. ниже.

  - *layout*: содержит все файлы XML-макетов, которые используются для определения пользовательского интерфейса приложения. Каждая активность имеет хотя бы один файл XML-разметки, описывающий интерфейс пользователя. Для пробного приложения Hello World в этой папке создается единственный файл *activity_main.xml*.

  - *mipmap*: здесь хранятся иконки запуска (launcher icons). Эта папка содержит файлы *ic_launcher.xml* для определения значков, которые используются для отображения на главном экране. Здесь содержатся значки различных типов плотности в зависимости от размера устройства, такие как hdpi, mdpi, xhdpi. Для каждой поддерживаемой плотности экрана есть своя подпапка. Плотность экрана (число пикселей на дюйм) определяет требуемое разрешение изображения. Android обобщает все актуальные плотности, распределяя их по группам, таким как medium (mdpi), high (hdpi) или extra-extra-extra-high (xxxhdpi). Папка *ic_launcher.png* содержит иконки запуска по умолчанию для всех поддерживаемых приложением плотностей.

  - *raw*: создаётся внутри папки *res* (например, *app/src/main/res/raw*) при необходимости (соответственно, в некоторых проектах по умолчанию может отсутствовать) и предназначена для хранения "сырых" файлов, которые приложение может использовать напрямую, например, mp3, mp4, sfb и другие необработанные данные. Файлы в *res/raw* доступны как ресурсы через ID, который генерируется в классе `R` (например, `R.raw.filename`), что позволяет обращаться к ним в коде как ресурсам, при этом имена файлов должны быть в нижнем регистре, без специальных символов (соответствует ограничениям Android по именам ресурсов). Имеет встроенную поддержку компилятором Android (проверка на время сборки).

  - *values*: используется для хранения значений ресурсов, которые задействованы во многих проектах Android, для включения функций цвета, стилей, размеров и т.д. Вместо того чтобы жёстко задавать такие значения, как строки, размеры и цвета непосредственно файлах XML и Java, рекомендуется определять их в соответствующих файлах *values*. Такая практика позволяет легче менять значения и обеспечивать их согласованность по всему приложению.

    Подпапка *values* включает следующие подкаталоги:

    - *colors.xml*: XML-файл, который используется для хранения цветов для ресурсов, содержит стандартные цвета для выбранной темы. Сюда можно добавлять свои цвета или изменять существующие в соответствии с требованиями приложения. Проект Android содержит 3 основных цвета, а именно: `colorPrimary`, `colorPrimaryDark`, `colorAccent`. Эти цвета также используются в некоторых предопределенных ресурсах Android studio. Эти цвета по мере необходимости должны быть непрозрачными, иначе это может привести к возникновению некоторых исключений.

    - *dimens.xml*: хранит размеры элементов и объектов для разных разрешений.

    - *strings.xml*: здесь находятся строковые ресурсы. Для всех строк в приложении следует создавать ресурсы. Это облегчает перевод на другие языки и многоязыковую поддержку.

    - *styles.xml*: сюда собираются  все стили для приложения и темы. Стили помогают создать единый внешний вид для всех элементов пользовательского интерфейса.

    - *themes*: в этой папке находятся файлы тем. В Android современные проекты используют файл *themes.xml* в папке *res/values/themes* (а также версии с суффиксами для разных вариантов, например, *themes.xml (night)* для ночной темы). В этом файле задаются основные темы приложения — совокупность стилей и цветовых схем, которые определяют внешний вид пользовательского интерфейса на уровне всего приложения или активности. Темы позволяют централизованно настраивать цвета, шрифты, стили кнопок и других элементов UI, управлять светлой и тёмной темами, а также настраивать Material Design атрибуты (такие как `colorPrimary`, `colorSecondary`, `textAppearance` и многие другие). В *themes.xml* обычно определяется базовая тема приложения, а также дифференцируются разные конфигурации темы для разных API или режимов (например, ночной режим). Использование тем упрощает поддержку единого стилевого оформления и позволяет быстро менять общий дизайн приложения без необходимости менять каждый отдельный элемент.

  - *xml*: папка *xml* внутри *res* используется для хранения различных XML-файлов конфигураций и других ресурсов, которые не относятся к стандартным *layout* или *values*. К примеру, сюда могут помещаться: конфигурации для систем Android, такие как сетевые политики (network security config), уведомления, XML-дескрипторы анимаций, настройка виджетов и др.; ресурсы для создания кастомных компонентов, например, селекторы состояний (`StateListDrawable`), анимации переходов (`TransitionDrawable`) или другие XML-ресурсы, которые можно использовать в приложении по ID; различные файлы, которые загружаются программно с помощью `Resources.getXml()` или `XmlPullParser`. Папка *res/xml* часто используется для декларативного описания настроек и конфигураций, позволяя отделять их от кода и изменять без перекомпиляции логики. Примеры файлов: *network_security_config.xml*, *appwidget_provider_info.xml*, *file_paths.xml* и др. Шаблон Empty Views Activity в этой папке создает два файла, используемые для настройки резервного копирования и извлечения данных приложения:

    - *backup_rules.xml*: этот файл используется для задания правил резервного копирования данных приложения с помощью встроенных механизмов Android Backup, таких как Auto Backup или Key/Value Backup. В *backup_rules.xml* определяют, какие файлы, папки и настройки приложения должны включаться или исключаться из резервных копий системы. Это особенно важно, чтобы не сохранять временные, кэшированные или пользовательские данные, которые не нужно восстанавливать. В результате Android Backup сервисы будут оперировать с указанными правилами, сохраняя и восстанавливая лишь нужные файлы.

    - *data_extraction_rules.xml*: этот XML-файл используется для настройки правил извлечения (data extraction) пользовательских данных из приложения. Он связан с процессом перехода на новое устройство, восстановления данных и экспорта пользовательской информации. Здесь задаются политики, какие данные приложения можно предоставлять для резервирования или переноса между устройствами, а какие — нет. Данный файл помогает контролировать, какие именно файлы и данные доступны для инструментов извлечения и восстановления, помогает ОС и инструментам переноса данных понимать, что именно можно копировать, обрабатывать и сохранять при миграции пользователя на другое устройство.

- **Сгенерированные ресурсы**

    Папка *res (generated)* в Android Studio — это автоматически сгенерированная системой папка, которая обычно содержит ресурсы и файлы, созданные или сконструированные инструментами сборки (Gradle) во время компиляции проекта. Она отличается от обычной папки *res* тем, что:

    - *res (generated)* автоматически создаётся и управляется системой сборки, служит для временных или промежуточных артефактов, которые нужны для сборки приложения;

    - в ней могут содержаться сгенерированные ресурсы, такие как файлы сгенерированных `R.java` классов, сгенерированные XML или другие ресурсы, которые создаются автоматически, но не редактируются вручную разработчиком;

    - разработчики обычно не редактируют содержимое папки *res (generated)* напрямую.

    Таким образом, папка *res (generated)* — это часть внутреннего механизма сборки Android Studio и Gradle, и она отделена от той папки *res*, где размещаются реальные ресурсы для приложения.

    Если нужно увидеть папку *res (generated)*, то следует переключиться в режим просмотра **Project** или **Packages** в Android Studio, так как в режиме **Android** она может быть скрыта.

Ресурсы позволяют добавлять в приложение произвольные файлы, такие как текст, XML, HTML, шрифты, музыку и видео. Если попытаться добавить эти файлы в качестве "ресурсов", Android обработает их в своей системе ресурсов, и будет уже невозможно получить исходные данные. Для того, чтобы хранить ресурсы в неизменном виде, можно самостоятельно создать папку активов *assets*. Папка *assets* создаётся вручную в Android Studio на том же уровне, что и папка *res*. После этого в нее можно добавлять любые файлы с произвольными именами и структурой каталогов. Эти файлы не будут иметь сгенерированных ID и доступны будут через класс `AssetManager`.

- **Активы**

    Папка *assets* создаётся вручную при необходимости (по умолчанию отсутствует в проекте) и служит для хранения произвольных файлов: текстовых, XML, HTML, шрифтов, музыки, видео и т.п. Файлы в *assets* сохраняются в неизменном виде, и к ним можно получить доступ в рантайме через класс `AssetManager` (например, открывая потоки), при этом Android не обрабатывает их как ресурсы. Данная папка позволяет хранить файлы с гибкими именами и вложенными каталогами, а их содержимое не подвергается проверке во время компиляции. Поддерживает динамический доступ — возможность получить список файлов во время выполнения (динамический доступ).

Папки *assets* и *raw* в проекте Android Studio предназначены для хранения дополнительных файлов, которые не являются ресурсами в привычном смысле, и имеют разные особенности доступа и использования. Ниже приведена таблица, позволяющая понять, когда необходимо создавать папки *assets* или *raw*.

Сценарий | Папка *assets* | Папка *res/raw*
-- | -- | --
Гибкое имя файла | ДА | НЕТ
Хранить в подкаталоге | ДА | НЕТ
Проверка во время компиляции | НЕТ | ДА
Список имен файлов во время выполнения | ДА | НЕТ
Имя файла, доступное из XML | НЕТ | ДА

Таким образом, если в созданном проекте не видно папок *assets* и *raw*, это нормально — они создаются при необходимости и не обязательны для каждого проекта. Если нужно хранить файлы, к которым нужен прямой, необработанный доступ, с гибкими именами и вложенной структурой, необходимо создать папку *assets* вручную. Если нужны ресурсы, которые должны быть доступны через ID и проверены системой ресурсов Android, следует использовать папку *res/raw*. Эта разница объясняет, почему в базовом проекте такие папки отсутствуют, и их стоит создавать только по мере необходимости.

Таблица для сравнения папок *assets* и *res/raw*:

| Особенность                      | *assets*                          | *res/raw*                                                |
| -------------------------------- | ------------------------------- | ------------------------------------------------------ |
| Создаётся по умолчанию           | Нет (нужно создать вручную)     | Нет (нужно создать вручную)                            |
| Тип файлов                       | Любые (текст, медиа, шрифты)    | Любые (например, mp3, mp4, sfb)                        |
| Имена файлов                     | Любые, включают вложенные папки | Строгие ограничения (нижний регистр, без спецсимволов) |
| Доступ в коде                    | Через `AssetManager` (потоки)     | Через `R.raw.filename`                                   |
| Возможность динамического списка | Да                              | Нет                                                    |
| Проверка компилятором            | Нет                             | Есть                                                   |

###### Using the editor pane / Панель редактора
Панель редактора появлятся при выборе файла. Для этого файла создается отдельная вкладка, что делает возможным открытие сразу нескольких файлов и переключение между ними. Например, при двойном нажатии на файле разметки ***activity_main.xml*** в панели **Project** > **Android**, откроется редактор макетов, как показано ниже.

![Activity layout tab](./img/as_activity_layout_tab.png)

При двойном щелчке на файле ***MainActivity***  в панели **Project** > **Android** откроется вкладка ***MainActivity.java*** со сменой редактора с разметки на код, как показано ниже:

![MainActivity tab](./img/as_mainactivity_tab.png)

В начале файла *MainActivity.java* находится оператор `package`, определяющий пакет приложения. За директивой `package` следует блок `import` в свернутом виде, что обозначают `...`, как показано на рисунке выше. Для раскрытия блока и просмотра содержимого необходимо нажать на многоточие. Операторы `import` позволяют импортировать библиотеки, необходимые для приложения. К примеру, следующая инструкция импортирует библиотеку `AppCompatActivity`:
```java
import android.support.v7.app.AppCompatActivity;
```

Каждая активность в приложении реализуется в виде класса Java. Следующее объявление расширяет класс `AppCompatActivity`, что позволяет обеспечить обратную совместимость реализуемого функционала с предыдущими версиями:
```java
public class MainActivity extends AppCompatActivity {
    // ... Rest of the code for the class.
}
```

##### Understanding the Android manifest / Манифест приложения Android
Прежде чем Android сможет запустить какой-либо компонент приложения, например `Activity`, система должна знать, что эта активность существует. Это обеспечивается считыванием манифеста приложения — файла *AndroidManifest.xml*, который описывает все компоненты Android-приложения. Каждая активность должна быть перечислена в этом XML-файле, вместе со всеми другими компонентами приложения.

Для просмотра и редактирования файла *AndroidManifest.xml* необходимо раскрыть папку *manifests* в панели **Project** > **Android** и дважды щелкнуть по *AndroidManifest.xml*. Его содержимое появится в панели редактирования:
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.android.helloworld">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
               <action android:name="android.intent.action.MAIN" />

               <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

###### Android namespace and application tag / Теги `namespace` и `application`
Android-манифест пишется в XML и всегда использует пространство имен Android:
```xml
xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.example.android.helloworld">
```

Выражение `package` отображает уникальное имя пакета нового приложения. Не следует изменять это выражение после публикации приложения.

Тег `<application>` вместе с закрывающим тегом `</application>` определяет настройки манифеста для всего приложения.

###### Automatic backup / Автоматическое резервное копирование
Атрибут `android:allowBackup` позволяет включить автоматическое резервное копирование данных приложения:
```xml
android:allowBackup="true"
```

Установка атрибута `android:allowBackup` в значение `true` позволяет автоматически создавать резервные копии приложения и восстанавливать их при необходимости. Пользователи тратят время и усилия на настройку приложений. Переход на новое устройство может привести к потере всей этой выверенной конфигурации. Для того чтобы этого не происходило, система по умолчанию выполняет автоматическое резервное копирование практически всех данных приложения, причем делает это так, что разработчику не приходится писать никакого дополнительного кода.

Для приложений с целевой версией SDK Android 6.0 (уровень API 23) и более устройства на Android 6.0 и выше создают резервные копии данных приложений в облако автоматически, поскольку атрибут `android:allowBackup` по умолчанию равен `true`, даже если он не указан. Для приложений с уровнем API ниже 23 необходимо явно добавить атрибут `android:allowBackup` и установить его значение в `true`.

**Совет**: узнать больше об автоматическом резервном копировании приложения можно в статье [Настройка автоматического резервного копирования для приложений](https://developer.android.com/training/backup/autosyncapi.html).

### Добавление перехода на другой экран
Чтобы добавить переход на экран регистрации (`RegistrationActivity`) в обработчик кнопки `regBtn`, нужно в методе обработчика создать `Intent` для запуска `RegistrationActivity` и вызвать метод `startActivity()`.

```kotlin
package com.example.stitch_tracker

import android.content.Intent
import android.os.Bundle
import androidx.activity.enableEdgeToEdge
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast


class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.auth_activity)

        val loginBtn = findViewById<Button>(R.id.enterBtn)
        val loginBox = findViewById<EditText>(R.id.loginTxtBox)

        val regBtn = findViewById<Button>(R.id.regBtn)

        loginBtn.setOnClickListener {
            val userName = loginBox.text.toString()
            Toast.makeText(this, "Добро пожаловать, $userName!", Toast.LENGTH_SHORT).show()
        }
        regBtn.setOnClickListener {
            val intent = Intent(this@MainActivity, RegistrationActivity::class.java)
            startActivity(intent)
        }
    }
}
```

- Добавляем импорт `android.content.Intent`.

- В обработчике нажатия `regBtn` создаем `Intent` для перехода на `RegistrationActivity`.

- Запускаем `startActivity` с этим `Intent`.

Теперь при нажатии на кнопку регистрации будет открываться экран регистрации. Не забудьте убедиться, что `RegistrationActivity` добавлена в манифест.

В Android, в том числе и при программировании на Kotlin, `Intent` — это объект, который представляет собой "намерение" выполнить какое-то действие. Он используется для взаимодействия между компонентами приложения или даже между разными приложениями.

Основная роль `Intent` — это описание того, что вы хотите сделать. Например, вы хотите:

- Запустить другой экран (`Activity`) вашего приложения,

- Открыть веб-страницу в браузере,

- Позвонить по телефону,

- Отправить письмо.

В контексте вашего кода:
```kotlin
val intent = Intent(this@MainActivity, RegistrationActivity::class.java)
startActivity(intent)
```

- Создаётся объект `Intent` с указанием, что вы хотите перейти из текущей активности (`this@MainActivity`) в экран регистрации (`RegistrationActivity::class.java`).

- Метод `startActivity(intent)` говорит системе Android "запусти экран, который описан в этом Intent".

Это называется **явным вызовом Intent** (explicit intent), когда вы конкретно указываете, какое `Activity` хотите открыть.

Также существуют неявные `Intent`, когда вы говорите системе "я хочу сделать вот такое действие" (например, открыть ссылку), а система сама выбирает, какое приложение или экран для этого запустит.

Итого, `Intent` — это средство коммуникации в Android, которое позволяет запускать экраны, сервисы и другие компоненты, передавать данные и управлять навигацией внутри и между приложениями.

Аргументы:
- `packageContext`: контекст пакета (контекст текущей активности). В Kotlin внутри вложенных лямбд, анонимных классов или других контекстов `this` по умолчанию ссылается на текущий объект или функцию, в которой вы находитесь. Например, внутри слушателя кнопки `OnClickListener` `this` будет указывать на этот слушатель, а не на вашу `Activity`. Чтобы явно обратиться к объекту текущей активности (`MainActivity`), используют синтаксис `this@MainActivity`. Это указывает на "этот объект класса MainActivity", то есть на саму активность, а не на вложенный объект. Оператор `@` в Kotlin используется для указания метки (label), которая помогает явно указать, к какому объекту или области кода вы обращаетесь. Он часто применяется, чтобы избежать двусмысленности, например, с ключевым словом `this`. `this@MainActivity` — означает "взять `this` именно текущей активности `MainActivity`", а не какую-то вложенную область или объект, в которую вы могли попасть (например, лямбда или анонимный класс). Таким образом вы избегаете путаницы и явно берёте контекст активности, который нужен для создания `Intent` или других операций.
- `clc`: класс компонента (класс активности назначения). В Kotlin `::class` — это оператор, который возвращает объект `KClass` (рефлексию) для заданного класса. В Kotlin оператор `::` называется оператором ссылки на функцию или класс (function/class reference operator). Он используется для получения ссылки на функцию, конструктор или класс в виде объекта, который можно передать как параметр, сохранить в переменную или использовать в других местах. Таким образом, оператор `::` позволяет в Kotlin оперировать функциями и классами как объектами, передавать и использовать их референсы. Это одна из особенностей функционального и рефлексивного подхода в Kotlin. Однако Android требует объект класса Java (`Class<...>`), поэтому добавляется `.java`, чтобы получить Java-совместимый класс. Итого: `RegistrationActivity::class` — объект класса Kotlin для `RegistrationActivity` (ссылка на Kotlin-объект класса (KClass)); `.java` — получение из него Java-класса (`Class<...>`), который нужен Android для работы с интентами;`RegistrationActivity::class.java` — класс Java, который использует Android для создания `Intent`.

Так формируется `Intent`, который запускает `RegistrationActivity` из `MainActivity`.

### Добавление экрана проектов

#### RelativeLayout
[689b9c7d63e4ad8e0adf43a4](https://metanit.com/java/android/3.3.php)

Исходя из названия, `RelativeLayout` (рус. *относительный макет* или если перефразировать – макет с относительным расположением элементов) может располагать элементы относительно друг друга. У его вложенных элементов есть ряд параметров для указания зависимостей относительно остальных элементов или же самого `RelativeLayout`.

**`RelativeLayout`** представляет объект `ViewGroup`, который располагает дочерние элементы относительно позиции других дочерних элементов разметки или относительно области самой разметки `RelativeLayout`. Используя относительное позиционирование, можно установить элемент по правому краю или в центре или иным способом, который предоставляет данный контейнер.

Элементы внутри `RelativeLayout` имеют свойства, отвечающие за их расположение по вертикали и горизонтали. По умолчанию горизонтальное свойство расположения прижато к левому краю `RelativeLayout`, а вертикальное — к верхнему. Получается, что по умолчанию расположение элементов зависят от верхнего и левого края родительского контейнера `RelativeLayout`. Часто такое зависящее от чего-то расположение для удобства называют зависимостью. Например, установить для текста зависимость снизу от кнопки и справа от родительского контейнера. Если вы не указывать ни одной зависимости, то все элементы будут располагаться один над одним в верхнем левом углу. Причём элемент, который будет ниже всего в xml файле будет находиться поверх остальных.

Для установки элемента в файле xml можно применять следующие атрибуты:

- **`android:layout_above`**: располагает элемент над элементом с указанным Id

- **`android:layout_below`**: располагает элемент под элементом с указанным Id

- **`android:layout_toLeftOf`**: располагается слева от элемента с указанным Id

- **`android:layout_toRightOf`**: располагается справа от элемента с указанным Id

- **`android:layout_toStartOf`**: располагает начало текущего элемента, где начинается элемент с указанным Id

- **`android:layout_toEndOf`**: располагает начало текущего элемента, где завершается элемент с указанным Id

- **`android:layout_alignBottom`**: выравнивает элемент по нижней границе другого элемента с указанным Id

- **`android:layout_alignLeft`**: выравнивает элемент по левой границе другого элемента с указанным Id

- **`android:layout_alignRight`**: выравнивает элемент по правой границе другого элемента с указанным Id

- **`android:layout_alignStart`**: выравнивает элемент по линии, у которой начинается другой элемент с указанным Id

- **`android:layout_alignEnd`**: выравнивает элемент по линии, у которой завершается другой элемент с указанным Id

- **`android:layout_alignTop`**: выравнивает элемент по верхней границе другого элемента с указанным Id

- **`android:layout_alignBaseline`**: выравнивает базовую линию элемента по базовой линии другого элемента с указанным Id

- **`android:layout_alignParentBottom`**: если атрибут имеет значение `true`, то элемент прижимается к нижней границе контейнера

- **`android:layout_alignParentRight`**: если атрибут имеет значение `true`, то элемент прижимается к правому краю контейнера

- **`android:layout_alignParentLeft`**: если атрибут имеет значение `true`, то элемент прижимается к левому краю контейнера

- **`android:layout_alignParentStart`**: если атрибут имеет значение `true`, то элемент прижимается к начальному краю контейнера (при левосторонней ориентации текста — левый край)

- **`android:layout_alignParentEnd`**: если атрибут имеет значение `true`, то элемент прижимается к конечному краю контейнера (при левосторонней ориентации текста — правый край)

- **`android:layout_alignParentTop`**: если атрибут имеет значение `true`, то элемент прижимается к верхней границе контейнера

- **`android:layout_centerInParent`**: если атрибут имеет значение `true`, то элемент располагается по центру родительского контейнера

- **`android:layout_centerHorizontal`**: при значении `true` выравнивает элемент по центру по горизонтали

- **`android:layout_centerVertical`**: при значении `true` выравнивает элемент по центру по вертикали

Для позиционирования относительно другого элемента, нам надо указать `id` этого элемента.

Использование `RelativeLayout` позволяет увеличить производительность приложения, так как получается «плоский» интерфейс (без вложений).

#### Сравнение RelativeLayout и ConstraintLayout
`RelativeLayout` и `ConstraintLayout` — оба эти контейнеры предназначены для размещения элементов интерфейса в Android, но они имеют существенные отличия по возможностям и принципам работы:

`RelativeLayout`:
- позволяет позиционировать дочерние элементы относительно друг друга или относительно родителя;

- использует простые правила вроде: «расположи кнопку справа от другого элемента», «центрируй по родителю» и т.д.

- подходит для простых макетов с небольшим числом элементов;

- при сложных интерфейсах часто приводит к вложенности других Layout, что ухудшает производительность и усложняет поддержку.

`ConstraintLayout`:
- более современный и мощный контейнер;

- позволяет задавать ограничения (constraints) между элементами: например, привязать любой край элемента к любому краю другого элемента или родителя;

- поддерживает горизонтальные и вертикальные цепочки (chains), bias (смещение от центра), а также гибкое управление видимостью элементов;

- обеспечивает создание сложных и адаптивных макетов без глубокой вложенности.

- работает быстрее в сложных макетах, так как снижает количество уровней вложенности.

- имеет визуальный редактор с точками привязки, облегчая дизайн интерфейсов в Android Studio.

| Критерий                 | `RelativeLayout`                | `ConstraintLayout`                                     |
| ------------------------ | ----------------------------- | ---------------------------------------------------- |
| Принцип позиционирования | Относительно других элементов | Ограничения (constraints) между элементами           |
| Сложность макета         | Хорош для простых макетов     | Отлично подходит для сложных, адаптивных интерфейсов |
| Глубина вложенности      | Может быть глубокой           | Позволяет избежать глубокой вложенности              |
| Производительность       | Меньше возможностей, но проще | Быстрее при сложных интерфейсах                      |
| Поддержка в редакторе    | Простая                       | Визуальный редактор с удобной привязкой              |

Для новых и сложных интерфейсов рекомендуется использовать `ConstraintLayout`, поскольку он более гибкий и эффективный.

Если интерфейс простой — `RelativeLayout` может подойти быстрее и проще.

### Добавление блока идентификации пользователя с аватаркой

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageView
        android:id="@+id/avatarImg"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:contentDescription="Аватарка"
        android:src="@drawable/avatar"
        android:scaleType="fitCenter"
    />
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/login_name"
        android:textSize="20sp"
        android:textStyle="bold|italic"
        android:fontFamily="@font/anticva"
        android:layout_toEndOf="@id/avatarImg"
        />
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/email"
        android:layout_toEndOf="@id/avatarImg"
        android:layout_alignBottom="@id/avatarImg"
        />

</RelativeLayout>
```

#### Работа с изображением
`scaleType` позволяет задать способ размещения и масштабирования картинки.
- `center`
- `centerInside`
- `centerCrop`
- `fitXY`
- `fitStart`

#### Добавление подчеркивания
Чтобы сделать текст подчеркнутым в Android, можно использовать один из следующих способов:

1. В XML это стандартно недоступно.

    В атрибутах `TextView` нет встроенного свойства для подчеркивания. Используйте programmatically или с помощью HTML.

2. Через HTML в строковом ресурсе.

    Можно воспользоваться тегом `<u>` в строковом ресурсе:
    ```xml
    <string name="underlined_text"><u>Подчеркнутый текст</u></string>
    ```

    И определить в `TextView`:
    ```xml
    android:text="@string/underlined_text"
    android:textAppearance="?android:attr/textAppearanceMedium"
    ```

3. В коде с помощью `SpannableString`.

    Можно программно добавить подчеркивание:
    ```kotlin
    val content = SpannableString("Подчеркнутый текст")
    content.setSpan(UnderlineSpan(), 0, content.length, 0)
    textView.text = content
    ```

4. Через `paintFlags`

    Ещё один способ (добавляет подчеркивание всему тексту `TextView`):
    ```kotlin
    textView.paintFlags = textView.paintFlags or Paint.UNDERLINE_TEXT_FLAG
    ```

Итог:
- XML: напрямую нельзя, необходимо использовать HTML или программный подход.

- В коде: проще всего — `paintFlags` или `SpannableString` для части текста.
Чтобы добавить таблицу списка проектов с нужными столбцами в этот `RelativeLayout`, лучший вариант — использовать компонент `TableLayout`.

### Добавление рамки

#### Рамка полей ввода
Чтобы изменить подсветку рамок полей ввода (`EditText`) при фокусе на зеленый цвет и настроить толщину рамки, нужно создать кастомный drawable с нужными параметрами и применить его как фон для `EditText`.

Пример, как сделать это с помощью XML drawable:
1. Создать файл в папке *res/drawable*, например, `edittext_custom_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Состояние фокуса включено -->
    <item android:state_focused="true">
        <shape android:shape="rectangle">
            <solid android:color="#FFFFFF" /> <!-- Цвет фона -->
            <stroke
                android:width="3dp"           <!-- Толщина рамки -->
                android:color="#4CAF50" />    <!-- Зеленый цвет рамки -->
            <corners android:radius="4dp" />  <!-- Скругление углов -->
            <padding
                android:left="8dp"
                android:top="8dp"
                android:right="8dp"
                android:bottom="8dp" />
        </shape>
    </item>

    <!-- Состояние фокуса выключено -->
    <item>
        <shape android:shape="rectangle">
            <solid android:color="#FFFFFF" />
            <stroke
                android:width="1dp"
                android:color="#CCCCCC" />    <!-- Цвет рамки без фокуса -->
            <corners android:radius="4dp" />
            <padding
                android:left="8dp"
                android:top="8dp"
                android:right="8dp"
                android:bottom="8dp" />
        </shape>
    </item>
</selector>
```

2. В XML с формой указать этот drawable как фон для `EditText`:

```xml
<EditText
    android:id="@+id/editTextEmail"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:layout_weight="1"
    android:background="@drawable/edittext_custom_background"
    android:padding="12dp"
    android:hint="Введите Email"
    android:inputType="textEmailAddress" />
```

Так при фокусе рамка станет зеленой с толщиной 3dp, а в обычном состоянии — серой и тоньше.

Если нужно программно менять цвет рамки или использовать `backgroundTint`, это менее гибко для настройки толщины.

Также можно настроить скругления и цвета под свои нужды.

Этот подход работает на большинстве версий Android и обеспечивает кастомный вид рамок при фокусе.

Цветовое выделение можно сделать проще, без создания кастомного drawable, используя стандартные свойства `backgroundTint` и `colorControlActivated` темы для изменения цвета рамки при фокусе.

Вот как сделать это:

1. В `EditText` указать простой фон (чаще всего стандартный — ё@android:drawable/edit_textё) или вообще не переопределять фон, чтобы он оставался стандартным.

2. Добавить атрибут `android:backgroundTint` с нужным цветом — он будет влиять на цвет акцента при фокусе.

Пример:
```xml
<EditText
    android:id="@+id/editTextEmail"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:layout_weight="1"
    android:hint="Введите Email"
    android:inputType="textEmailAddress"
    android:backgroundTint="#4CAF50"    <!-- Зеленый цвет подсветки -->
    android:padding="12dp" />
```

При фокусе контур (обычно нижняя линия у стандартного `EditText`) подсветится зелёным цветом `#4CAF50`.

Толщину рамки менять нельзя этим способом — она зависит от стандартного стиля системных виджетов.

Если используются Material Design компоненты (`com.google.android.material.textfield.TextInputLayout`), там можно гибко указать цвет активной линии рамки через атрибуты темы и стили.

Вывод:

- Чтобы просто изменить цвет подсветки при фокусе — использовать `android:backgroundTint`.

- Чтобы изменить толщину рамки — нужен кастомный drawable или использовать Material Components с настройками стилей.

### TableLayout / Добавление списков
Контейнер `TableLayout` структурирует элементы управления в виде таблицы по столбцам и строкам.

Используя элемент **`TableRow`**, создаем отдельную строку. Как разметка узнает сколько столбцов надо создать? Android находит строку с максимальным количеством виджетов одного уровня, и это количество будет означать количество столбцов. Например, в данном случае определены две строки и в каждой по два элемента. Если бы в какой-нибудь из них было бы три виджета, то соответственно столбцов было бы также три, даже если в другой строке осталось бы два виджета.

Причем элемент `TableRow` наследуется от класса `LinearLayout`, поэтому к нему можно применять тот же функционал, что и к `LinearLayout`. В частности, для определения пространства для элементов в строке используется атрибут `android:layout_weight`.

Если какой-то элемент должен быть растянут на ряд столбцов, то можно растянуть его с помощью атрибута **`layout_span`**, который указывает на какое количество столбцов надо растянуть элемент.

Также можно растянуть элемент на всю строку, установив у него атрибут `android:layout_weight="1"`:

```xml
<TableLayout
        android:id="@+id/projectsTable"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/avatarImg"
        android:layout_marginTop="24dp"
        android:stretchColumns="*">

        <TableRow android:background="#CCCCCC" android:padding="8dp">
            <TextView
                android:text="Название"
                android:textStyle="bold"
                android:padding="8dp"/>
            <TextView
                android:text="Дата старта"
                android:textStyle="bold"
                android:padding="8dp"/>
            <TextView
                android:text="Вышито"
                android:textStyle="bold"
                android:padding="8dp"/>
            <TextView
                android:text="Осталось"
                android:textStyle="bold"
                android:padding="8dp"/>
            <TextView
                android:text="Дата окончания"
                android:textStyle="bold"
                android:padding="8dp"/>
        </TableRow>

        <!-- Здесь в коде Java/Kotlin вы будете динамически добавлять новые строки с проектами -->

    </TableLayout>
```

Объяснение:
- добавлен `TableLayout` с одной фиксированной строкой заголовков (`TableRow`).

- задано свойство `stretchColumns="*"` — чтобы все колонки занимали доступное пространство равномерно.

- таблица позиционируется под аватаркой через `android:layout_below="@id/avatarImg"` с отступом сверху.

Далее в активности можно динамически добавлять `TableRow` для каждого проекта с нужными данными.

Если таблица не влезает по ширине, то для того, чтобы она не обрезалась по горизонтали и её содержимое корректно помещалось на экране, есть несколько решений:

1. Обернуть `TableLayout` в `HorizontalScrollView`

    Это самый простой способ, позволяющий сделать таблицу прокручиваемой по горизонтали:

    ```xml
    <HorizontalScrollView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:fillViewport="true"
            android:layout_below="@id/avatarImg"
            android:scrollbars="horizontal">

        <TableLayout
            android:id="@+id/projectsTable"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:stretchColumns="*">

            <!-- Строки таблицы -->

        </TableLayout>
    </HorizontalScrollView>
    ```

2. Уменьшить ширину колонок или размер текста

   - Можно уменьшить `padding` и размер текста в `TextView`.
   - Можно задать фиксированные ширины колонок, чтобы лучше контролировать их размеры.

3. Добавить переносы текста внутри таблицы.

    Для динамических ширин столбцов с переносом текста в `TableLayout` обычно используют комбинацию атрибутов `shrinkColumns` и `stretchColumns` вместе с ограничением ширины `TextView` и переносом текста.

   1. В `TableLayout` в XML добавить:

        ```xml
        android:stretchColumns="*"
        android:shrinkColumns="*"
        ```

        - `shrinkColumns="*"` в `TableLayout` позволяет столбцам сжиматься, чтобы не выходить за экран.

        - `stretchColumns="*"` равномерно растягивает колонки, заполняя ширину.

        Это позволит столбцам расширяться и сжиматься по необходимости, занимая доступное место и уменьшая ширину, если не помещается.

   2. Для заголовков (и других ячеек) в `TextView` внутри `TableRow` задайте:

        ```xml
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:maxLines="3"
        android:ellipsize="none"
        android:scrollHorizontally="false"
        android:breakStrategy="simple"     <!-- для API 23+ улучшенный перенос -->
        android:hyphenationFrequency="normal"  <!-- для API 23+ -->
        ```

        - `layout_width="0dp"` и `layout_weight="1"` сделают ширину ячейки гибкой, пропорционально доступному пространству.

        - `maxLines="3"`  задаёт максимальное количество строк, на которые может переноситься текст, что позволит переносить текст максимум на 3 строки.

        - `ellipsize="none"`  отключает отображение троеточия и позволяет показывать текст полностью, что отключит сокращение текста.

        - `scrollHorizontally="false"` запрещает горизонтальную прокрутку текста в `TextView`.

        - `breakStrategy` и `hyphenationFrequency` помогают делать переносы более корректными на новых версиях Android.

        Итог
        - `shrinkColumns="*"` в `TableLayout` позволяет столбцам сжиматься, чтобы не выходить за экран.

        - `stretchColumns="*"` равномерно растягивает колонки, заполняя ширину.

        - Гибкая ширина через `layout_weight` и `layout_width="0dp"` позволяет автоматически подстраивать размер столбцов.

        - Перенос текста регулируется `maxLines`, `ellipsize` и `scrollHorizontally`.

        Так таблица будет адаптивной, с динамической шириной колонок и переносом текста в ячейках, при этом не выходя за пределы экрана. Если нужно, помогу подготовить полный обновленный пример разметки.

3. Использовать `ConstraintLayout` с Chain или `RecyclerView` для сложных таблиц

    Для сложных или адаптивных интерфейсов лучше переходить на более гибкие решения, но для простого случая достаточно обернуть в горизонтальный скролл.

### Добавление прокрутки
Если часть содержимого в интерфейсе с использованием `ConstraintLayout` не помещается на экране телефона (например, при маленьком размере экрана или в портретной ориентации), то без специальной обработки часть элементов может оказаться за пределами видимой области, что приведёт к тому, что пользователь не сможет их увидеть, прокрутить и взаимодействовать с ними.

Основные последствия и способы решения:

- **Отсутствие прокрутки**: По умолчанию `ConstraintLayout` не поддерживает прокрутку. Если содержимого больше, чем экран, нижние элементы могут оказаться скрытыми.

- **Отсутствие видимости**: Элементы вне области экрана не будут видны и недоступны.

Для правильной работы с длинным содержимым нужно использовать **`ScrollView`** или **`NestedScrollView`** в качестве контейнера, внутри которого будет `ConstraintLayout`. Это позволит пользователю прокручивать содержимое, когда оно не помещается целиком на экран.

Как сделать содержимое прокручиваемым с `ConstraintLayout`:

1. Обернуть `ConstraintLayout` в `ScrollView` (для вертикальной прокрутки):

    ```xml
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            ...>

            <!-- элементы -->

        </androidx.constraintlayout.widget.ConstraintLayout>

    </ScrollView>
    ```

2. Обязательно установить у `ConstraintLayout` `android:layout_height="wrap_content"`, чтобы высота корректно подстраивалась под содержимое, и `ScrollView` мог прокручивать.

3. Если нужно горизонтальное прокручивание — вместо `ScrollView` использовать `HorizontalScrollView` (реже применяется).

Дополнительные рекомендации:
- использовать Guideline и Chains внутри `ConstraintLayout` для более адаптивного позиционирования элементов.

- можно применять `android:layout_constrainedHeight="true"` или `android:layout_constrainedWidth="true"` для ограничения размеров, чтобы не выходить за пределы экрана.

- прорабатывать адаптивность UI с помощью размеров в `dp` и процентов, чтобы элементы корректно масштабировались.

Таким образом, если часть содержимого не помещается на экране, без `ScrollView` пользователь не сможет увидеть нижние элементы. Чтобы решить это, необходимо оборачивать `ConstraintLayout` в `ScrollView`, чтобы обеспечить прокрутку и доступность всего содержимого.

## Android 06: 2025-08-19
Previous activities recap:
- [x] Скорректировали [способ хранения шрифтов](#рекомендации-по-хранению-шрифтов) — добавили ресурсы шрифтов в СКВ.
- [x] Познакомились с [манифестами](#understanding-the-android-manifest--манифест-приложения-android) Android и разобрали файл главного манифеста.
- [x] Разобрались как добавлять новые активности и почему важно это делать через интерфейс IDE Android Studio (см. выше манифест). Таким образом, сделали [переход](#добавление-перехода-на-другой-экран) на другой экран (регистрации) по нажатию кнопки "Регистрация".
- [x] Сверстали новый экран "Проекты" с использованием двух новых компоновщиков — [`RelativeLayout`](#relativelayout) для секции с аватаркой (блока идентификации пользователя) и `TableLayout` для таблицы проектов.
- [x] При работе над блоком идентификации пользователя попробовали [работу с растровыми изображениями](#работа-с-изображением) в Android Studio. Также рассмотрели разные варианты и возможности форматирования текста. Кроме того, разобрались с тем, как можно делать рамки.
- [x] При работе со списком проектов познакомились с особенностями компоновищка [`TableLayout`](#tablelayout--добавление-списков)

Scheduled activities:
- [ ] Добавить/изменить значок запуска приложения
- [ ] Разобрать передачу данных между активностями
- [ ] Добавить простейшую валидацию на форму регистрации
- [ ] Добавить виджеты показать/скрыть пароль на форму регистрации
- [ ] Экстрактировать таблицу проектов в отдельный файл макета

### Добавление иконки быстрого запуска
Чтобы добавить иконку запуска приложения в Android Studio, можно воспользоваться встроенным инструментом Image Asset. Вот пошаговая инструкция для актуальных версий Android Studio:

1. В окне проекта найте папку *app*.

2. Кликнуть по папке *app* правой кнопкой мыши и выбрать **New** → **Image Asset**.

3. В открывшемся окне Asset Studio в пункте **Icon Type** выбрать **Launcher Icons (Adaptive & Legacy)**.

4. В параметре **Asset Type** установить галочку на **Image**.

5. Нажать на значок папки около параметра **Path (Patch)**, чтобы выбрать свое изображение, которое станет иконкой приложения. Формат изображения должен быть, например, PNG размером около 512x512 пикселей.

6. При необходимости подогнать размер изображения с помощью параметра **Resize**.

7. Нажать **Next**, выбратб каталог *main* в поле **Res Directory**, после чего нажать **Finish**.

Для замены иконки во всех конфигурациях проекта повторить шаги, но в поле **Res Directory** выбрать также **debug** и **release**.

После этих шагов иконка приложения в эмуляторе и при установке на устройство сменится на выбранное изображение.

Альтернативный способ — вручную положить изображение в папку *drawable* и указать в файле *AndroidManifest.xml* строку:
```xml
android:icon="@drawable/название_изображения"
```

Но использование Image Asset предпочтительнее, так как автоматизирует процесс и создает все необходимые ресурсы для разных размеров экранов.

Таким образом, с помощью Image Asset в Android Studio можно легко добавить иконку запуска приложения

### Передача данных
Передачу данных между активностями можно организовать через `Intent`. Пример передачи данных при переходе с одного экрана на другой продемонстрирован ниже.

Отправка данных в исходной активности:
```kotlin
// Пример обработчика по кнопке регистрации:
registerBtn.setOnClickListener {
    val login = loginField.text.toString()
    val fullName = fullNameField.text.toString()
    val avatarResId = R.drawable.avatar1 // или другой способ получения/выбора аватарки

    // После успешной регистрации
    val intent = Intent(this@RegistrationActivity, UserActivity::class.java)
    intent.putExtra("LOGIN", login)
    intent.putExtra("FULL_NAME", fullName)
    intent.putExtra("AVATAR_RES_ID", avatarResId)
    startActivity(intent)
    finish()
}
```

Прием данных в целевой активности:
```kotlin
package com.example.stitch_tracker

import android.os.Bundle
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity

class UserActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_user)

        // Получаем данные из Intent
        val login = intent.getStringExtra("LOGIN")
        // Получаем целевой элемент
        val loginBox = findViewById<TextView>(R.id.loginBox)
        // Устанавливаем данные в целевой элемент
        loginBox.text = login

        val fullName = intent.getStringExtra("FULL_NAME")
        val avatarResId = intent.getIntExtra("AVATAR_RES_ID", R.drawable.default_avatar)

        val avatarView = findViewById<ImageView>(R.id.avatarImageView)
        val loginView = findViewById<TextView>(R.id.loginTextView)
        val nameView = findViewById<TextView>(R.id.fullNameTextView)

        avatarView.setImageResource(avatarResId)
        loginView.text = login
        nameView.text = fullName
    }
}
```

### Добавление простейшей валидации
Простейшая реализация заключается в том, чтобы проверять поля на заполненность и в случае обнаружения пустого поля выводить пользователю сообщения о необходимости его заполнения:
```kotlin
package com.example.stitch_tracker

import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity

class RegistrationActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.registration_activity)

        val loginInput = findViewById<EditText>(R.id.etxtLog)
        val emailInput = findViewById<EditText>(R.id.etxtName)
        val passwordInput = findViewById<EditText>(R.id.etxtPassRep)
        val registerBtn = findViewById<Button>(R.id.submitBtn)

        registerBtn.setOnClickListener {
            val login = loginInput.text.toString()
            val email = emailInput.text.toString()
            val password = passwordInput.text.toString()

            if (login.isNotEmpty() && password.isNotEmpty()) {
                // Здесь можно добавить валидацию и логику регистрации
                Toast.makeText(this, "Регистрация успешно выполнена!\n$login", Toast.LENGTH_SHORT).show()
                finish() // Закрыть регистрацию и вернуться назад
            } else {
                Toast.makeText(this, "Пожалуйста, введите логин и пароль", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

В случае, если поля заполнены, то происходит закрытие (завершение) текущей активности (`RegistrationActivity`), что влечет за собой автоматическое возобновление приостановленной предыдущей активности (`MainActivity`).

Расширим код регистрации, чтобы:

- проверять, что все поля заполнены;

- проверять валидность введенных данных (email и т.п.);

- показывать ошибки через `EditText.setError`.

- после успешной регистрации переходить обратно к `MainActivity` или в любую другую.

Усовершенствования:

- Поскольку количесто проверок довольно большое, то для финальной проверки удобно использовать единую переменную-флаг, показывающую валидность всей формы (`isValid`).

- В проверках на пустоту функции `isNotEmpty` заменим на `isBlank`, учитывающую пробельные символы.

##### Проверка на пустоту
Для проверки строк на пустоту в Kotlin в основном используются функции `isEmpty`/`isNotEmpty` и `isBlank`/`isNotBlank`.

Основное отличие в их применении связано с тем, какие строки они считают пустыми:

- `isEmpty()` проверяет, что строка не содержит символов вовсе (длина 0). Если строка пустая (`""`), то `isEmpty()` возвращает `true`. Если строка содержит хотя бы один символ, включая пробелы, возвращает `false`.

- `isNotEmpty()` — противоположность `isEmpty()`, возвращает `true`, если строка содержит хотя бы один символ.

- `isBlank()` расширяет понятие пустоты: она возвращает `true`, если строка либо пустая, либо состоит только из пробельных символов (пробел, табуляция, перенос строки и другие Unicode whitespace-символы).

- `isNotBlank()` — противоположность `isBlank()`, возвращает `true`, если строка содержит хотя бы один непустой (непробельный) символ.

Таким образом, разница состоит в следующем:

- `isEmpty()` не учитывает пробелы, пробельные строки считаются не пустыми.

- `isBlank()` учитывает пробелы, пробельные строки считаются пустыми.

Пример:
```kotlin
"".isEmpty() // true
" ".isEmpty() // false

"".isBlank() // true
" ".isBlank() // true
```

Также `isNotEmpty()` и `isNotBlank()` — обратные им методы, проверяющие соответственно наличие хотя бы одного символа или хотя бы одного непробельного символа.

Таким образом, если нужно проверить, что строка не пуста именно символами, включая пробелы — используют `isEmpty`/`isNotEmpty`. Если требуется проверить, что строка не пуста и не содержит только пробелы — предпочитают `isBlank`/`isNotBlank`.

Обновленный *RegistrationActivity.kt*:
```kotlin
package com.example.stitch_tracker

import android.content.Intent
import android.os.Bundle
import android.util.Patterns
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity

class RegistrationActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_registration)

        val usernameInput = findViewById<EditText>(R.id.regUsername)
        val emailInput = findViewById<EditText>(R.id.regEmail)
        val passwordInput = findViewById<EditText>(R.id.regPassword)
        val registerBtn = findViewById<Button>(R.id.registerBtn)

        registerBtn.setOnClickListener {
            val username = usernameInput.text.toString().trim()
            val email = emailInput.text.toString().trim()
            val password = passwordInput.text.toString()

            // Очистка старых ошибок
            usernameInput.error = null
            emailInput.error = null
            passwordInput.error = null

            var isValid = true

            // Валидация имени
            if (username.isEmpty()) {
                usernameInput.error = "Введите имя пользователя"
                isValid = false
            }

            // Валидация email
            if (email.isEmpty()) {
                emailInput.error = "Введите Email"
                isValid = false
            } else if (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
                emailInput.error = "Неверный формат Email"
                isValid = false
            }

            // Валидация пароля
            if (password.isEmpty()) {
                passwordInput.error = "Введите пароль"
                isValid = false
            } else if (password.length < 6) {
                passwordInput.error = "Пароль должен быть не менее 6 символов"
                isValid = false
            }

            if (isValid) {
                // Здесь можно добавить логику регистрации: запросы на сервер и т.п.
                Toast.makeText(this, "Регистрация успешна!\nДобро пожаловать, $username!", Toast.LENGTH_SHORT).show()

                // По успешной регистрации — перейти в MainActivity (или другую)
                val intent = Intent(this, MainActivity::class.java)
                intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
                startActivity(intent)
                finish() // Закрыть текущую активность
            }
        }
    }
}
```

Здесь используется встроенный в Android механизм валидации e-mail, который предоставляется классом `Patterns` из пакета `android.util`.

Фрагмент `Patterns.EMAIL_ADDRESS.matcher(email).matches()`:

- `Patterns.EMAIL_ADDRESS` — это предопределённое регулярное выражение в Android для проверки корректности e-mail адреса.

- `matcher(email)` создаёт объект `Matcher` для проверки строки email на соответствие этому шаблону.

- `matches()` возвращает `true`, если вся строка `email` соответствует шаблону, то есть если это валидный адрес электронной почты.

Фрагмент `emailInput.error = "Неверный формат электронной почты"`:

- Этот код задаёт сообщение об ошибке для элемента интерфейса ввода `emailInput` (например, `EditText`).

- Если email не прошёл проверку, пользователю показывается это сообщение прямо под полем ввода, чтобы он понял причину ошибки.

Итого, валидация работает так:

- проверяется, что поле не пустое.

- если пустое — выводится ошибка "Введите адрес почты";

- если заполнено — проверяется формат через `Patterns.EMAIL_ADDRESS.matcher(email).matches()`;

- если формат неверный — выводится ошибка "Неверный формат электронной почты";

- если всё корректно — ошибок нет (`isValid` остаётся `true`);

Это стандартный и рекомендуемый способ проверки email в Android, так как он использует системное регулярное выражение, покрывающее большинство правил корректности email-адресов. При этом сообщение об ошибке через `emailInput.error` используется для удобной и понятной обратной связи пользователю.

Такой подход упрощает работу с валидацией и делает код более читаемым и надёжным.

> Стоит отметить, что атрибут `inputType="email"` у элемента `EditText` в Android влияет в первую очередь на поведение клавиатуры — подставляет клавиатуру для ввода email с символами `@` и `.`, а также немного подсказывает системе, что ввод предполагается как email. Сам по себе `inputType="email"` не выполняет валидацию — он лишь упрощает ввод для пользователя, поэтому для полноценной проверки валидности email надо программно проверять содержимое поля, как в примере выше.

В типичном подходе делают так:

- В XML для `EditText` указывают `android:inputType="textEmailAddress"` (чтобы правильно показывалась клавиатура).

- В коде добавляют слушатель (например, `TextWatcher` или `onFocusChangeListener`), который после ввода проверяет, соответствует ли строка формату email через `Patterns.EMAIL_ADDRESS`.

- Если не соответствует, устанавливают ошибку в `editText.setError("Ошибка формата")`.

Таким образом, `inputType` улучшает UX, а валидация остается за кодом.

Пример кода в Kotlin с `TextWatcher`:
```kotlin
editTextEmail.inputType = InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS

editTextEmail.addTextChangedListener(object : TextWatcher {
    override fun afterTextChanged(s: Editable?) {
        val email = s.toString().trim()
        if (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            editTextEmail.error = "Неверный формат электронной почты"
        } else {
            editTextEmail.error = null
        }
    }
    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
})
```

Для проверки пароля по заданным критериям (не менее 8 символов, наличие хотя бы одной буквы в верхнем регистре, одной буквы в нижнем регистре, цифры и специального символа) можно использовать регулярное выражение, которое проверит все эти условия одновременно.

Пример регулярного выражения на Java/Android:
```java
String PASSWORD_PATTERN = 
    "^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@#$%^&+=!]).{8,}$";
```

В Kotlin:
```kotlin
val PASSWORD_PATTERN = "^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@#\$%^&+=!]).{8,}\$"
```

Объяснение:

- `^` и `$` — начало и конец строки

- `(?=.*[A-Z])` — проверяет, что есть хотя бы одна заглавная буква

- `(?=.*[a-z])` — проверяет, что есть хотя бы одна строчная буква

- `(?=.*\\d)` — проверяет, что есть хотя бы одна цифра

- `(?=.*[@#$%^&+=!])` — проверяет, что есть хотя бы один специальный символ из набора (его можно расширять по необходимости)

- `.{8,}` — проверяет, что длина строки не менее 8 символов

Пример использования проверки:
```java
boolean isValid = Pattern.compile(PASSWORD_PATTERN).matcher(password).matches();
if (!isValid) {
    passwordInput.error = "Пароль должен содержать не менее 8 символов, включая заглавную и строчную буквы, цифру и спецсимвол";
}
```

В Kotlin:
```kotlin
val PASSWORD_PATTERN = "^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@#\$%^&+=!]).{8,}\$"

val isValid = Regex(PASSWORD_PATTERN).matches(password)
if (!isValid) {
    passwordInput.error = "Пароль должен содержать не менее 8 символов, включая заглавную и строчную буквы, цифру и спецсимвол"
}
```

`Regex(PASSWORD_PATTERN).matches(password)` создаёт `regex` из строки и проверяет, совпадает ли вся строка password с шаблоном. Ошибка выводится так же, как в Java — присваивается полю `error` у элемента ввода пароля.

Такой подход аналогичен валидации email: используется регулярное выражение для проверки соответствия строки требованиям, а в UI через `passwordInput.error` отображается сообщение, если пароль не проходит проверку.

Итоговый код:
```kotlin
package com.example.stitch_tracker

import android.content.Intent
import android.os.Bundle
import android.util.Patterns
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity

class RegistrationActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.registration_activity)

        val loginInput = findViewById<EditText>(R.id.etxtLog)
        val emailInput = findViewById<EditText>(R.id.etxtEmail)
        val passwordInput = findViewById<EditText>(R.id.etxtPass)
        val passwordRepeat = findViewById<EditText>(R.id.etxtPassRep)
        val registerBtn = findViewById<Button>(R.id.submitBtn)

        val name = findViewById<EditText>(R.id.etxtLname)

        registerBtn.setOnClickListener {
            val login = loginInput.text.toString()
            val email = emailInput.text.toString()
            val password = passwordInput.text.toString()
            val pwdRepeat = passwordRepeat.text.toString()

            var isValid = true
            val loginMaxLength = 30

            // Checking login
            if (login.isBlank()) {
                isValid = false
                loginInput.error = "Введите имя пользователя"
            }
            else if (login.length > loginMaxLength) {
                isValid = false
                loginInput.error = "Имя не должно превышать $loginMaxLength символов"
            }

            // Checking email
            if (email.isBlank()) {
                isValid = false
                emailInput.error = "Введите адрес почты"
            }
            else if (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
                isValid = false
                emailInput.error = "Неверный формат электронной почты"
            }

            val PASSWORD_PATTERN = "^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@#\$%^&+=!]).{8,}\$"
            if (password.isBlank()) {
                isValid = false
                passwordInput.error = "Укажите пароль"
            }
            else if(!Regex(PASSWORD_PATTERN).matches(password))
            {
                isValid = false
                passwordInput.error = "Пароль должен содержать не менее 8 символов, включая заглавную и строчную буквы, цифру и спецсимвол"
            }
            else if (password != pwdRepeat)
            {
                isValid = false
                passwordRepeat.error = "Пароли должны совпадать"
            }

            if (isValid) {
                // Здесь можно добавить логику регистрации: запросы на сервер и т.п.
                Toast.makeText(this, "Регистрация успешна!\nДобро пожаловать, $login!", Toast.LENGTH_SHORT).show()

                // По успешной регистрации — перейти в MainActivity (или другую)
                val intent = Intent(this, MainActivity::class.java)
                intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
                startActivity(intent)
                finish() // Закрыть текущую активность
            }
            else {
                Toast.makeText(this, "Проверьте поля формы и заполните их валидными данными", Toast.LENGTH_SHORT).show()
            }


//            if (login.isNotBlank() && password.isNotBlank()) {
//                // Здесь можно добавить валидацию и логику регистрации
//                Toast.makeText(this, "Регистрация успешно выполнена!\n$login", Toast.LENGTH_SHORT).show()
//                finish() // Закрыть регистрацию и вернуться назад
//            } else {
//                Toast.makeText(this, "Пожалуйста, введите логин и пароль", Toast.LENGTH_SHORT).show()
//            }
        }
    }
}
```

Итоговое поведение:
- При нажатии на кнопку "Регистрация" в `MainActivity` открывается новая активность регистрации с компактной формой (лейблы и поля в одной строке, выравнивание и равная ширина).

- При вводе данных и нажатии кнопки в регистрационной форме происходит проверка:

  - пустые поля помечаются ошибками;

  - email проверяется на правильный формат;

  - пароль проверяется на минимальную длину и критерии сложности;

  - пароли проверяются на совпадение;

- если валидация прошла — показывается приветствие и происходит возврат обратно в `MainActivity`;

- если ошибки — пользователю показываются ошибки в соответствующих полях.

Дальнейшие варианты возможных улучшений:

- добавление виджетов выбора дат и скрытия/показа паролей;
- инкапсуляция валидации в объекте пользователя;
- экстракция валидации во вспомогательный валидационный сервис.

Можно исполльзовать оба варианта — общий функционал экстрактировать в базовый сервис, а специфичные проверки перенести в конкретные классы (`User`, `Project` и т.д.). Для этого необходимо грамотно спроектировать классы так, чтобы можно было реализовать проверки как в консольном приложении, так и в формах мобильного приложения.

### Создание вспомогательных виджетов для полей ввода

#### Подключение виджета выбора дат
Для подключения удобного выбора даты через `DatePickerDialog` к вашему полю ввода даты рождения (`EditText`), можно сделать так: В `RegActivity` (или вашей активности регистрации) подключите `DatePickerDialog` к `EditText` для даты рождения:
```kotlin
import android.app.DatePickerDialog
import android.os.Bundle
import android.widget.EditText
import androidx.appcompat.app.AppCompatActivity
import java.util.Calendar

class RegActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.your_layout) // замените на имя вашего layout

        val birthdateEditText = findViewById<EditText>(R.id.birthdateTxb)

        // Сделаем EditText не редактируемым напрямую, чтобы пользоваться только DatePicker
        birthdateEditText.isFocusable = false
        birthdateEditText.isClickable = true

        birthdateEditText.setOnClickListener {
            // Получаем текущую дату для инициализации DatePicker
            val calendar = Calendar.getInstance()
            val year = calendar.get(Calendar.YEAR)
            val month = calendar.get(Calendar.MONTH)
            val day = calendar.get(Calendar.DAY_OF_MONTH)

            val datePickerDialog = DatePickerDialog(this, { _, selectedYear, selectedMonth, selectedDay ->
                // Форматируем дату (мес+1, так как месяц с 0)
                val formattedDate = String.format("%02d.%02d.%04d", selectedDay, selectedMonth + 1, selectedYear)
                birthdateEditText.setText(formattedDate)
            }, year, month, day)

            datePickerDialog.show()
        }
    }
}
```

 Краткие пояснения:
- `birthdateEditText.isFocusable = false` и `isClickable = true` сделают поле только для выбора через `DatePicker`, не позволяя напрямую вводить текст с клавиатуры;

- при клике на поле открывается стандартный системный `DatePickerDialog`;

- после выбора даты дата записывается в поле в формате `дд.мм.гггг`;

- можно изменить формат даты при необходимости.

Запись вида:
```kotlin
val formattedDate = String.format("%02d.%02d.%04d", selectedDay, selectedMonth + 1, selectedYear)
```

означает следующее:

- метод `String.format` используется для форматирования строки по заданному шаблону;

- шаблон `%02d.%02d.%04d"` описывает форматирование трёх целочисленных значений (`d` — для целых чисел);

- `%02d` — форматирует число с ведущим нулём, если число меньше 2 знаков (например, 1 станет "01");

- `%04d` — форматирует число минимум до 4 знаков, добавляя ведущие нули при необходимости (для года).

Аргументы, которые подставляются на место форматировщиков:

- `selectedDay` — день (например, 5 станет "05"),

- `selectedMonth + 1` — месяц увеличен на 1, потому что в программировании месяцы считаются с 0 (0 — январь),

- `selectedYear` — год.

В итоге эта команда формирует строку даты в формате "день.месяц.год", например "05.09.2025".

То есть этот код преобразует три числа (день, месяц, год) в строку даты вида "ДД.ММ.ГГГГ" с ведущими нулями у дня и месяца, если они меньше 10

##### Форматирование строк
<dfn title="форматирование строк">Форматирование строк</dfn> в Kotlin — это набор методов и средств для создания строк с подставленными значениями и определённым стилем представления данных.

Основные варианты форматирования строк в Kotlin:

1. **Строковые шаблоны (String Templates)**

    Позволяют вставлять значения переменных и выражений прямо внутрь строки с помощью знака доллара **`$`**.
    Примеры:
    ```kotlin
    val name = "Маша"
    println("Привет, $name!") // Привет, Маша!

    val a = 5
    val b = 3
    println("Сумма: ${a + b}") // Сумма: 8
    ```

    В фигурных скобках можно писать любые выражения Kotlin.

2. **Метод `String.format()`**

    Работает аналогично методу `format` из Java, где в строке-шаблоне используются спецификаторы формата с символом **`%`** и параметрами для подстановки значений. Пример:
    ```kotlin
    val formatted = String.format("Число: %04d", 7)
    println(formatted) // Число: 0007
    ```

    Часто используется для форматирования чисел с ведущими нулями, точностью, выравниванием и т. д.

    При помощи `String.format` можно задавать точность при выводе чисел  с плавающей точкой и округлением, например:
    ```kotlin
    val pi = 3.14159
    println(String.format("%.2f", pi)) // 3.14
    ```

    Спецификаторы формата:

    - `%s` — строка

    - `%d` — целое число

    - `%f` — число с плавающей точкой

    - `%02d` — целое число с минимум двумя символами, с ведущим нулём
    и т.п.

3. **Использование классов для форматирования (например, `DecimalFormat` в Java)**

    Kotlin совместим с Java, поэтому можно использовать Java-классы для более сложного форматирования чисел.

Таким образом, для простого и удобного форматирования в Kotlin чаще всего используются строковые шаблоны с `$` и `${}`. Для более сложного точного форматирования лучше применять `String.format()` с шаблонами формата.

Это облегчает работу с текстовыми данными, позволяет красиво выводить отформатированные числа, даты и другие переменные в нужном виде.

#### Добавление виджета скрытия/показа пароля
Для ввода пароля в Android можно добавить виджет "скрыть/показать пароль" с иконкой, обычно это глаз, который при нажатии переключает видимость вводимого текста.

Есть несколько способов сделать это:

1. **Использование TextInputLayout из Material Components (самый простой)**

    Если используется `TextInputLayout` вместе с `TextInputEditText`, то можно включить встроенный переключатель пароля так:
    ```xml
    <com.google.android.material.textfield.TextInputLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:passwordToggleEnabled="true">  <!-- Включает переключатель -->

        <com.google.android.material.textfield.TextInputEditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Введите пароль"
            android:inputType="textPassword"/>

    </com.google.android.material.textfield.TextInputLayout>
    ```

    Для этого нужно подключить библиотеку Material Components в проект.

2. **Вручную с `EditText` и `ImageView`**

В XML размещается `EditText` для пароля и кнопка-иконка (например, `ImageView` с иконкой глаза):
```xml
<RelativeLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <EditText
        android:id="@+id/edit_password"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="textPassword"
        android:hint="Пароль"/>

    <ImageView
        android:id="@+id/togglePasswordVisibility"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentEnd="true"
        android:layout_centerVertical="true"
        android:src="@drawable/ic_eye_closed" /> <!-- иконка глаза -->
</RelativeLayout>
```

или с использованием другого компоновщика:
```xml
<FrameLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <EditText
        android:id="@+id/edit_password"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Пароль"
        android:inputType="textPassword"
        android:paddingEnd="40dp" />  <!-- Оставляем отступ справа под кнопку -->

    <ImageView
        android:id="@+id/togglePasswordVisibility"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:layout_gravity="end|center_vertical"
        android:layout_marginEnd="8dp"
        android:src="@drawable/ic_eye_closed"
        android:contentDescription="Переключить видимость пароля"
        android:clickable="true"
        android:focusable="true"/>
</FrameLayout>
```

#### Использование FrameLayout для создания наложений

#### Использование scope-функций для рефакторинга кода
```kotlin
val PASSWORD_PATTERN = "^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@#\$%^&+=!]).{8,}\$"
if (password.isBlank()) {
    isValid = false
    passwordInput.error = "Укажите пароль"
}
else if(!Regex(PASSWORD_PATTERN).matches(password))
{
    isValid = false
    passwordInput.error = "Пароль должен содержать не менее 8 символов, включая заглавную и строчную буквы, цифру и спецсимвол"
}
else if (password != pwdRepeat)
{
    isValid = false
    passwordRepeat.error = "Пароли должны совпадать"
}
```

Дальнейшие усовершенствования:
- [ ] Динамическое наполнение таблицы с программным добавлением строк
- [ ] Оформление ячеек таблицы
- [ ] Адаптация таблицы под `RecyclerView` для производительности на больших списках
- [ ] Создание скрываемых и разворачиваемых областей
